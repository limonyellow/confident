{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Confident Confident helps you create configuration objects from multiple sources such as files, environment variables and maps. Confident BaseConfig class is a data model that enforce validation and type hints by using pydantic library. With Confident you can manage multiple configurations depends on the environment your code is deployed. While having lots of flexibility how to describe your config objects, Confident will provide visibility of the process and help you expose misconfiguration as soon as possible. Example import os from confident import BaseConfig # Creating your own config class by inheriting from `BaseConfig`. class MyAppConfig(BaseConfig): port: int = 5000 host: str = 'localhost' labels: list # Illustrates some environment variables. os.environ['host'] = '127.0.0.1' os.environ['labels'] = '[\"FOO\", \"BAR\"]' # JSON strings can be used for more types. # Creating the config object. `BaseConfig` will load the values of the properties. config = MyAppConfig() print(config.host) # > 127.0.0.1 print(config.json()) # > {\"port\": 5000, \"host\": \"127.0.0.1\", \"labels\": [\"FOO\", \"BAR\"]} print(config) # > port=5000 host='127.0.0.1' labels=['FOO', 'BAR'] print(config.full_fields()) # > { # 'port': ConfigField(name='port', value=5000, origin_value=5000, source_name='MyAppConfig', source_type='class_default', source_location=PosixPath('~/confident/readme_example.py')), # 'host': ConfigField(name='host', value='127.0.0.1', origin_value='127.0.0.1', source_name='host', source_type='env_var', source_location='host'), # 'labels': ConfigField(name='labels', value=['FOO', 'BAR'], origin_value='[\"FOO\", \"BAR\"]', source_name='labels', source_type='env_var', source_location='labels') # } Installation (.venv) $ pip install confident Capabilities Customized Fields Loaders Built-in loaders: - Environment variables. - Config files such as 'json' and 'yaml'. - Config maps to load fields depends on the environment. (See documentation) It is possible to configure the loading priority and add your own loader classes. Full Support of Pydantic BaseSettings Confident core functionality is based on pydantic library. That means BaseConfig object has all the benefits of pydantic's BaseModel and BaseSettings including type validation, object transformation and many more features. Config Loading visibility BaseConfig object stores details about the fields loading process and offers ways to understand the source of each loaded field. Details about the origin value (before conversion), the location of the source and the type of loader, can all be accessed from the object. Examples More examples can be found in the project's repository . Contributing To contribute to Confident, please make sure any new features or changes to existing functionality include test coverage.","title":"Confident"},{"location":"#confident","text":"Confident helps you create configuration objects from multiple sources such as files, environment variables and maps. Confident BaseConfig class is a data model that enforce validation and type hints by using pydantic library. With Confident you can manage multiple configurations depends on the environment your code is deployed. While having lots of flexibility how to describe your config objects, Confident will provide visibility of the process and help you expose misconfiguration as soon as possible.","title":"Confident"},{"location":"#example","text":"import os from confident import BaseConfig # Creating your own config class by inheriting from `BaseConfig`. class MyAppConfig(BaseConfig): port: int = 5000 host: str = 'localhost' labels: list # Illustrates some environment variables. os.environ['host'] = '127.0.0.1' os.environ['labels'] = '[\"FOO\", \"BAR\"]' # JSON strings can be used for more types. # Creating the config object. `BaseConfig` will load the values of the properties. config = MyAppConfig() print(config.host) # > 127.0.0.1 print(config.json()) # > {\"port\": 5000, \"host\": \"127.0.0.1\", \"labels\": [\"FOO\", \"BAR\"]} print(config) # > port=5000 host='127.0.0.1' labels=['FOO', 'BAR'] print(config.full_fields()) # > { # 'port': ConfigField(name='port', value=5000, origin_value=5000, source_name='MyAppConfig', source_type='class_default', source_location=PosixPath('~/confident/readme_example.py')), # 'host': ConfigField(name='host', value='127.0.0.1', origin_value='127.0.0.1', source_name='host', source_type='env_var', source_location='host'), # 'labels': ConfigField(name='labels', value=['FOO', 'BAR'], origin_value='[\"FOO\", \"BAR\"]', source_name='labels', source_type='env_var', source_location='labels') # }","title":"Example"},{"location":"#installation","text":"(.venv) $ pip install confident","title":"Installation"},{"location":"#capabilities","text":"","title":"Capabilities"},{"location":"#customized-fields-loaders","text":"Built-in loaders: - Environment variables. - Config files such as 'json' and 'yaml'. - Config maps to load fields depends on the environment. (See documentation) It is possible to configure the loading priority and add your own loader classes.","title":"Customized Fields Loaders"},{"location":"#full-support-of-pydantic-basesettings","text":"Confident core functionality is based on pydantic library. That means BaseConfig object has all the benefits of pydantic's BaseModel and BaseSettings including type validation, object transformation and many more features.","title":"Full Support of Pydantic BaseSettings"},{"location":"#config-loading-visibility","text":"BaseConfig object stores details about the fields loading process and offers ways to understand the source of each loaded field. Details about the origin value (before conversion), the location of the source and the type of loader, can all be accessed from the object.","title":"Config Loading visibility"},{"location":"#examples","text":"More examples can be found in the project's repository .","title":"Examples"},{"location":"#contributing","text":"To contribute to Confident, please make sure any new features or changes to existing functionality include test coverage.","title":"Contributing"},{"location":"config_class/","text":"BaseConfig Settings Config class In addition to defining the object's behaviour by inserting key-value arguments, it is possible to change class behaviour using Config class. This configuration method is similar to pydantic Config class. from confident import BaseConfig class MyConfig(BaseConfig): title: str port: int = 5000 retry: bool = False class Config: # In this class the specifications of `MyConfig` will be defined. deployment_config = 'deploy.json' files = ['app_config/config1.json', 'app_config/config2.yaml'] ignore_missing_files = True This is equivalent to: from confident import BaseConfig class MyConfig(BaseConfig): title: str port: int = 5000 retry: bool = False config = MyConfig( _deployment_config='deploy.json', _files=['app_config/config1.json', 'app_config/config2.yaml'], _ignore_missing_files = True ) Changing The Loading Priority It is possible to change the loading order of fields from different sources. If a field value is present in multiple sources, the value from the highest priority source will be chosen and override the others. source_priority is an attribute that holds a list of ConfigSource - The first will have the highest priority and the last will have the lowest. Sources that their enum will not appear in the source_priority list, will not be loaded to the created object. from confident import BaseConfig, ConfigSource class MyConfig(BaseConfig): host: str port: int = 5000 class ConfidentConfig: # Here we define that environment vars will have the highest priority (even before explicit values). # Values from files and config maps will have lower priority than default values. source_priority = [ ConfigSource.env_var, ConfigSource.init, ConfigSource.class_default, ConfigSource.map, ConfigSource.file ]","title":"BaseConfig Settings"},{"location":"config_class/#baseconfig-settings","text":"","title":"BaseConfig Settings"},{"location":"config_class/#config-class","text":"In addition to defining the object's behaviour by inserting key-value arguments, it is possible to change class behaviour using Config class. This configuration method is similar to pydantic Config class. from confident import BaseConfig class MyConfig(BaseConfig): title: str port: int = 5000 retry: bool = False class Config: # In this class the specifications of `MyConfig` will be defined. deployment_config = 'deploy.json' files = ['app_config/config1.json', 'app_config/config2.yaml'] ignore_missing_files = True This is equivalent to: from confident import BaseConfig class MyConfig(BaseConfig): title: str port: int = 5000 retry: bool = False config = MyConfig( _deployment_config='deploy.json', _files=['app_config/config1.json', 'app_config/config2.yaml'], _ignore_missing_files = True )","title":"Config class"},{"location":"config_class/#changing-the-loading-priority","text":"It is possible to change the loading order of fields from different sources. If a field value is present in multiple sources, the value from the highest priority source will be chosen and override the others. source_priority is an attribute that holds a list of ConfigSource - The first will have the highest priority and the last will have the lowest. Sources that their enum will not appear in the source_priority list, will not be loaded to the created object. from confident import BaseConfig, ConfigSource class MyConfig(BaseConfig): host: str port: int = 5000 class ConfidentConfig: # Here we define that environment vars will have the highest priority (even before explicit values). # Values from files and config maps will have lower priority than default values. source_priority = [ ConfigSource.env_var, ConfigSource.init, ConfigSource.class_default, ConfigSource.map, ConfigSource.file ]","title":"Changing The Loading Priority"},{"location":"deployment_config/","text":"Config Maps Config maps in Confident is basically a dictionary of configurations values. Only one configuration will be loaded in execution time depends on a given map_name . Config maps can be either python dict or a file (json or yaml). multi_configs = { 'prod': { 'host': 'https://prod_server', 'log_level': 'info' }, 'dev': { 'host': 'http://dev_server', 'log_level': 'debug' }, 'local': { 'host': 'localhost', 'log_level': 'debug' }, } app/configs.json { \"prod\": { \"host\": \"https://prod_server\", \"log_level\": \"info\" }, \"dev\": { \"host\": \"http://dev_server\", \"log_level\": \"debug\" }, \"local\": { \"host\": \"localhost\", \"log_level\": \"debug\" } } The BaseConfig class definition can be as follows: from confident import BaseConfig class MainConfig(BaseConfig): host: str port: int = 5000 log_level: str = 'error' Now we can create the config object in several ways: # Using python dict: config_a = MainConfig(_map_name='local', _config_map=multi_configs) print(config_a) #> host='localhost' port=5000 log_level='debug' # Same, but from a file path: config_b = MainConfig(_map_name='local', _config_map='app/configs.json') print(config_b) #> host='localhost' port=5000 log_level='debug' Map Field If we want more flexibility in selecting the map to load, we can use a property to do so. map_field is a field declared in the Config object that its value will define what will be the map_name . from confident import BaseConfig class MainConfig(BaseConfig): current_map: str = 'local' # <-- This will be our `map_field`. host: str port: int = 5000 log_level: str = 'error' class Config: map_field = 'current_map' Now we can create the config object: config_a = MainConfig(_config_map=multi_configs) print(config_a) #> current_map='local' host='localhost' port=5000 log_level='debug' In the above example the map_field is current_map , the map_name in run time is local so the matching properties are loaded from the config_map . Notice that the map_field as every other field, can be loaded from a source: os.environ['current_map'] = 'dev' # Setting the field as an environment variable. config_c = MainConfig(_config_map='app/configs.json') print(config_c) #> current_deployment='dev' host='http://dev_server' port=5000 log_level='debug' Selecting the map_field can be done in class definition using MapField . MapField has the same functionality as pydantic Field . Declaration with MapField : from confident import BaseConfig, MapField class MainConfig(BaseConfig): my_map: str = MapField('local') # <-- This will be our `map_field`. host: str port: int = 5000 log_level: str = 'error' Declaration with Config class: from confident import Confident class MainConfig(Confident): my_map: str = 'local' host: str port: int = 5000 log_level: str = 'error' class ConfidentConfig: map_field = 'my_map' # <-- Marking `my_map` as our `map_field`. Usage is the same in both ways: import os os.environ['my_map'] = 'prod' config = MainConfig(_config_map='app/configs.json') print(config) #> my_map='prod' host='https://prod_server' port=5000 log_level='info'","title":"Config Maps"},{"location":"deployment_config/#config-maps","text":"Config maps in Confident is basically a dictionary of configurations values. Only one configuration will be loaded in execution time depends on a given map_name . Config maps can be either python dict or a file (json or yaml). multi_configs = { 'prod': { 'host': 'https://prod_server', 'log_level': 'info' }, 'dev': { 'host': 'http://dev_server', 'log_level': 'debug' }, 'local': { 'host': 'localhost', 'log_level': 'debug' }, } app/configs.json { \"prod\": { \"host\": \"https://prod_server\", \"log_level\": \"info\" }, \"dev\": { \"host\": \"http://dev_server\", \"log_level\": \"debug\" }, \"local\": { \"host\": \"localhost\", \"log_level\": \"debug\" } } The BaseConfig class definition can be as follows: from confident import BaseConfig class MainConfig(BaseConfig): host: str port: int = 5000 log_level: str = 'error' Now we can create the config object in several ways: # Using python dict: config_a = MainConfig(_map_name='local', _config_map=multi_configs) print(config_a) #> host='localhost' port=5000 log_level='debug' # Same, but from a file path: config_b = MainConfig(_map_name='local', _config_map='app/configs.json') print(config_b) #> host='localhost' port=5000 log_level='debug'","title":"Config Maps"},{"location":"deployment_config/#map-field","text":"If we want more flexibility in selecting the map to load, we can use a property to do so. map_field is a field declared in the Config object that its value will define what will be the map_name . from confident import BaseConfig class MainConfig(BaseConfig): current_map: str = 'local' # <-- This will be our `map_field`. host: str port: int = 5000 log_level: str = 'error' class Config: map_field = 'current_map' Now we can create the config object: config_a = MainConfig(_config_map=multi_configs) print(config_a) #> current_map='local' host='localhost' port=5000 log_level='debug' In the above example the map_field is current_map , the map_name in run time is local so the matching properties are loaded from the config_map . Notice that the map_field as every other field, can be loaded from a source: os.environ['current_map'] = 'dev' # Setting the field as an environment variable. config_c = MainConfig(_config_map='app/configs.json') print(config_c) #> current_deployment='dev' host='http://dev_server' port=5000 log_level='debug' Selecting the map_field can be done in class definition using MapField . MapField has the same functionality as pydantic Field . Declaration with MapField : from confident import BaseConfig, MapField class MainConfig(BaseConfig): my_map: str = MapField('local') # <-- This will be our `map_field`. host: str port: int = 5000 log_level: str = 'error' Declaration with Config class: from confident import Confident class MainConfig(Confident): my_map: str = 'local' host: str port: int = 5000 log_level: str = 'error' class ConfidentConfig: map_field = 'my_map' # <-- Marking `my_map` as our `map_field`. Usage is the same in both ways: import os os.environ['my_map'] = 'prod' config = MainConfig(_config_map='app/configs.json') print(config) #> my_map='prod' host='https://prod_server' port=5000 log_level='info'","title":"Map Field"},{"location":"usage/","text":"Basic Usage Load Environment Variables Simply create an object. Confident will load the property value from environment variable with the same name if exists. import os from confident import BaseConfig os.environ['port'] = 3000 class MyConfig(BaseConfig): port: int config = MyConfig() print(config) #> port=3000 Load Default Values Like in dataclass and pydantic classes, it is possible to declare default values of properties. from confident import BaseConfig class MyConfig(BaseConfig): port: int = 3333 config = MyConfig() print(config) #> port=3333 Load Config Files Confident supports json , yaml and .env files. app_config/config1.json { \"title\": \"my_app_1\", \"retry\": true, \"timeout\": 10 } app_config/config2.yaml title: my_yaml_app port: 3030 from confident import BaseConfig class MyConfig(BaseConfig): title: str port: int = 5000 retry: bool = False config = MyConfig(_files=['app_config/config1.json', 'app_config/config2.yaml']) print(config) #> title='my_app_1' port=3030 retry=True","title":"Basic Usage"},{"location":"usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"usage/#load-environment-variables","text":"Simply create an object. Confident will load the property value from environment variable with the same name if exists. import os from confident import BaseConfig os.environ['port'] = 3000 class MyConfig(BaseConfig): port: int config = MyConfig() print(config) #> port=3000","title":"Load Environment Variables"},{"location":"usage/#load-default-values","text":"Like in dataclass and pydantic classes, it is possible to declare default values of properties. from confident import BaseConfig class MyConfig(BaseConfig): port: int = 3333 config = MyConfig() print(config) #> port=3333","title":"Load Default Values"},{"location":"usage/#load-config-files","text":"Confident supports json , yaml and .env files. app_config/config1.json { \"title\": \"my_app_1\", \"retry\": true, \"timeout\": 10 } app_config/config2.yaml title: my_yaml_app port: 3030 from confident import BaseConfig class MyConfig(BaseConfig): title: str port: int = 5000 retry: bool = False config = MyConfig(_files=['app_config/config1.json', 'app_config/config2.yaml']) print(config) #> title='my_app_1' port=3030 retry=True","title":"Load Config Files"},{"location":"validation/","text":"Validation In order to avoid misconfigurations, Confident will supply indicative errors in case of wrong values or wrong sequence of arguments. For instance: Wrong or missing files provided. Inserting both map_name and map_field (causing ambiguous config map selection). Wrong types or missing values (by pydantic validation mechanism).","title":"Validation"},{"location":"validation/#validation","text":"In order to avoid misconfigurations, Confident will supply indicative errors in case of wrong values or wrong sequence of arguments. For instance: Wrong or missing files provided. Inserting both map_name and map_field (causing ambiguous config map selection). Wrong types or missing values (by pydantic validation mechanism).","title":"Validation"},{"location":"visibility/","text":"Visibility Confident provides built-in functions to show details about the object after creation. The details can be logged/printed and provide clarity about the source of every value in the object. Multiple Sources Recognition In order to monitor which fields were loaded from what source, full_fields() can be used. Notice the difference between the source types: import os from typing import List from confident import BaseConfig class AppConfig(BaseConfig): title: str = 'my_application' timeout: int input_paths: List[str] class Config: files='config.yaml' os.environ['input_paths'] = '[\"/tmp/input_a\", \"/tmp/input_b\"]' config = AppConfig() print(config.full_fields()) #> { # 'title': ConfigField(name='title', value='my_application', origin_value='my_application', source_name='AppConfig', source_type='class_default', source_location=WindowsPath('example.py')), # 'timeout': ConfigField(name='timeout', value=60, origin_value=60, source_name='config.yaml', source_type='file', source_location=WindowsPath('config.yaml')), # 'input_paths': ConfigField(name='input_paths', value=['/tmp/input_a', '/tmp/input_b'], origin_value='[\"/tmp/input_a\", \"/tmp/input_b\"]', source_name='input_paths', source_type='env_var', source_location='input_paths'), # } BaseConfig Object Source Priority The list of sources to load into the object, from the highest priority to the lowest: config.__source_priority__ #> ['init', 'env_var', 'map', 'file', 'class_default'] BaseConfig Object Creation Location The position of the the BaseConfig object declaration: config.__specs__.class_path #> PosixPath('~/MyProject/project_config.py') The position of the the BaseConfig object instance creation: config.__specs__.creation_path #> PosixPath('~/MyProject/main.py')","title":"Visibility"},{"location":"visibility/#visibility","text":"Confident provides built-in functions to show details about the object after creation. The details can be logged/printed and provide clarity about the source of every value in the object.","title":"Visibility"},{"location":"visibility/#multiple-sources-recognition","text":"In order to monitor which fields were loaded from what source, full_fields() can be used. Notice the difference between the source types: import os from typing import List from confident import BaseConfig class AppConfig(BaseConfig): title: str = 'my_application' timeout: int input_paths: List[str] class Config: files='config.yaml' os.environ['input_paths'] = '[\"/tmp/input_a\", \"/tmp/input_b\"]' config = AppConfig() print(config.full_fields()) #> { # 'title': ConfigField(name='title', value='my_application', origin_value='my_application', source_name='AppConfig', source_type='class_default', source_location=WindowsPath('example.py')), # 'timeout': ConfigField(name='timeout', value=60, origin_value=60, source_name='config.yaml', source_type='file', source_location=WindowsPath('config.yaml')), # 'input_paths': ConfigField(name='input_paths', value=['/tmp/input_a', '/tmp/input_b'], origin_value='[\"/tmp/input_a\", \"/tmp/input_b\"]', source_name='input_paths', source_type='env_var', source_location='input_paths'), # }","title":"Multiple Sources Recognition"},{"location":"visibility/#baseconfig-object-source-priority","text":"The list of sources to load into the object, from the highest priority to the lowest: config.__source_priority__ #> ['init', 'env_var', 'map', 'file', 'class_default']","title":"BaseConfig Object Source Priority"},{"location":"visibility/#baseconfig-object-creation-location","text":"The position of the the BaseConfig object declaration: config.__specs__.class_path #> PosixPath('~/MyProject/project_config.py') The position of the the BaseConfig object instance creation: config.__specs__.creation_path #> PosixPath('~/MyProject/main.py')","title":"BaseConfig Object Creation Location"}]}